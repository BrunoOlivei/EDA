# Introdução

Existem alguns tópicos avançados que, na maioria dos casos, não são aplicados aos sistemas EDA, porém são assuntos que valem ter o conhecimento:

1. Misturando EDA e Request  / Response 
2. EDA síncrono
3. Eventos como única fonte da verdade 
4. Padrão SAGA
5. EDA no Front End

# Misturando EDA e Request / Response

A maioria dos sistemas EDA não são puramente serviços de intercomunicação cuja arquitetura é única e exclusivamente baseada em eventos, mas utilizam outras formas de comunicação e a principal razão para isso é UI - User Interface, ou seja, o usuário e a usabilidade.

Isso se dá pois UI Clients precisam de respostas, por isso utilizam Web API para chamar serviços no backend. Se o cliente está requisitando apenas dados, então EDA provavelmente, não funcionará, pois EDA não foi desenhado para prover nenhuma resposta, lembrando que EDA é assíncrono. 

Para exemplificar como podemos utilizar EDA nesse processo, misturando com Request / Response. 

Um usuário adiciona um item ao carrinho, essa requisição é enviada a uma camada REST API que irá intermediar com o _Producer_, respondendo ao usuário a requisição, o _Producer_ então envia o evento para o _Channel_ que, consequentemente, encaminha para o _Consumer_ que lida com esse tipo de evento. 

![[mixing_eda_with_request_response]](https://github.com/BrunoOlivei/EDA/blob/main/Anexos/mixing_eda_with_request_response.svg)
# EDA Síncrono

Por natureza EDA é assíncrono, onde normalmente o _Producer_ não espera uma resposta pelo evento, ele simplesmente aciona o evento e envia para o _Channel_. Porém, em algumas situações, o _Producer_ requererá algum tipo de resposta ao evento e esperará por ele, que usualmente será um evento separado. 

Basicamente o _Producer_ roda duas threads simultâneas, uma que será responsável pelo envio dos eventos, a segunda que aguardará as respostas dos eventos enviados. O _Channel_ continua sendo o responsável por receber os eventos, e nesse caso, também enviará o evento de volta para o _Producer_, uma vez que esse evento de retorno será tratado como um novo evento, portanto _Channel_ saberá para quem enviar esse novo evento. 

![[eda_with_response.svg]]

A implementação não é tão simples, o que pode tornar o processo mais fácil é a criação de um _wrapper_ no _Producer_ e então esse _wrapper_ expõe uma API síncrona que chama o _Producer_ que irá realizar todo o trabalho enviando, esperando e processando a _response_.

![[synchronous_eda.svg]]

O usuário envia uma requisição com um comando que deve ser executado para o _wrapper_. O _wrapper_ então envia uma chamada de função para o _Producer_ solicitando que uma ação seja tomada que é o envio do evento. O _producer_ então envia o evento para o _Channel_ que roteia para o _Consumer_ responsável pelo evento e o _Channel_ retorna um novo evento, aqui vale ressaltar que o _Consumer_ não envia nenhuma resposta para o _Channel_, o _Channel_ retorna o evento para o _Producer_, que nesse cenário assume o papel de _Consumer_, que envia de volta para o _Wrapper_ e então retorna o status para o usuário. 

Do ponto de vista do usuário, todo esse processo ocorre síncrono, pois o _Wrapper_ mantém a thread rodando esperando que a resposta retorne do _Producer_.

Alguns pontos importantes:

- Implementação não é fácil
- Só implemente se tiver absoluta certeza da necessidade de uma resposta para um evento
- Alguns _Channels_, como o RabbitMQ, possuem nativamente suporte para esse processo. Nesse caso é só configurar qual tópico é necessário o retorno do evento, dessa forma o _Channel_ já irá esperar o retorno do evento para retornar o status do conteúdo deste evento, criando a ilusão de EDA síncrono.

# Eventos como única fonte da verdade 

Em sistemas tradicionais, o banco de dados mantém todo operacional relacionado a dados e os eventos acionam ações no sistema. Há uma outra abordagem onde o _Channel_ retém todos os eventos, tornando-se a única fonte da verdade, quando se trata das entidades relacionadas ao sistema. 

O que temos então é que, após o _Consumer_ receber, processar o evento e, deseja, salvar o resultado deste evento, ele simplesmente envia o resultado de volta para o _Channel_ que então armazena o evento. 

![[events_as_source_of_truth.svg]]

Essa abordagem só é relevante quando:

- Eventos são armazenados e desejamos poder acessar eventos passados.
- O _Channel_ possui algum tipo de linguagem de query
- A funcionalidade principal do sistema é voltada a streaming de eventos, sem nenhuma complexidade de interação. 

Uma forma clássica de se implementar eventos como fonte da verdade é utilizando o Apache Kafka, por reter os eventos por padrão e possuir a KQL query language (Kafka Query Language), possibilitando realizar consultas complexas dos eventos armazenados, também é desenvolvida para streaming de eventos. 

# Padrão SAGA


